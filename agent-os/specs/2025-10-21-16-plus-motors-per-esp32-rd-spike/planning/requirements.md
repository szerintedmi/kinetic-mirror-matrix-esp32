# Spec Requirements: 16-plus-motors-per-esp32-rd-spike

## Initial Description
16+ Motors per ESP32 (R&D Spike) — Validate shared STEP fan‑out idea with per‑motor STEP gating.  Check need for and compare 74HC125/126 vs 74LVC125/126 (and/or optional double‑inverted 74LVC14 pre‑buffer) for edge integrity, jitter, and fan‑out. Bench stop/resume at 10–50 ksteps/s; characterize max channels per ESP32. Deliver schematic/BOM recommendation and firmware gate‑timing notes. Depends on: 2, 4. `S`

## Requirements Discussion

### First Round Questions

**Q1:** I’m assuming we’ll use per-motor STEP gating via a quad buffer/tri-state (e.g., 74LVC125/126) on each motor’s STEP input rather than relying on EN/SLEEP gating. Is that correct, or do you prefer EN/SLEEP gating for the spike phase?
**Answer:** as the shared_step_spike_findings.md showed we might be able to rely on SLEEP gating. I would proceed with that approach for now - if any blocker issue arises we can always consider adding extra hardware for gating

**Q2:** I’m thinking the shared STEP pulse source should be generated by ESP32 hardware (RMT or LEDC PWM) with precise edge control, not FastAccelStepper. Should we prototype with RMT (and keep FAS only as an interface shim), or keep FAS as the pulse engine initially?
**Answer:** Explore potentially getting rid of FastAccelStepper and generate our STEPS ourselves. I would do a focused spike on this to see how feasible is that. Focus on most performant way doing it so we can ensure jitter free step generation even if later we introduce wifi / esp now 

**Q3:** I assume overlapping moves must share one common speed/accel profile; requests that differ either queue or get rejected with an error. Is that correct, or should we quantize to a small set of allowed rates instead?
**Answer:** the simplest is to remove per move speed / accel setting and introduce a new global SPEED and ACCEL setting  (which defaults to current defaults set in code). We can just reject changing them with an error code if any motor is moving

**Q4:** I’m assuming microsecond-scale DIR guard windows synced between STEP pulses (e.g., disable gate for 2–5 µs, flip DIR, re-enable before the next edge) are sufficient to avoid edge hazards. Is that acceptable, or do you want explicit datasheet-driven timing targets called out?
**Answer:** yes , but make sure you use constant for those gates and have proper unit test coverage as it's really hard to test manually

**Q5:** I’m assuming we should prefer LVC-family parts (3.3 V logic, faster edges) over HC-family for integrity and fan-out, possibly with an optional 74LVC14 pre-buffer (double-invert) before the per-motor 125/126 gates. Is that the direction, or should we compare HC125/126 vs LVC125/126 on the bench first?
**Answer:** no pre-buffer and stick to the current 74LHC595s - spike showed it works with them, if we have issues we can always complicate 

**Q6:** I’m assuming success criteria include clean stop/resume and direction flips at 10–50 ksteps/s with no missed pulses, validated by logic analyzer captures. Is that correct, or do you have different target rates or tolerance thresholds?
**Answer:** we are running the motors with 4000 steps/s so aiming to 10k steps is enough. have no logic analyzer / osciloscope so we need to figure manual bench tests without it: eg. running motors back and forth in different rithym and comparing physical position vs. tracked by MCU

**Q7:** I’m assuming we’ll add minimal telemetry: “pulses planned vs delivered” per motor, and timestamps for start/stop/DIR changes, accessible via STATUS/GET diagnostics. Should we also expose a `GET SHARED_STEP` config/status block for the spike?
**Answer:** I would not add telemetry until it's needed

**Q8:** I’m assuming the serial protocol remains unchanged for MVP, with only a global shared-step speed/accel default and a mode toggle (ENABLE/DISABLE shared-step) for test. Is that good, or do you want explicit new commands (e.g., `SET SHARED_STEP=SPEED=<v>,ACCEL=<a>`)?
**Answer:** serial protocol unchaned apart from removing current per move / homing accel / speed option to simplify parsing / command validation logic (see prev point about global SPEED/ACCEL.

**Q9:** Are there any clear exclusions for this spike (e.g., microstepping, mixed concurrent speeds, wireless orchestration interactions, or PCB layout work) that we should explicitly keep out of scope?
**Answer:** no microstepping, no wireless (apart from making sure it's robust enough to keep working generating accurate step pulses once we introduce wifi control later). no pcb layout 

### Existing Code to Reference
No similar existing features identified for reference.

### Follow-up Questions
None at this time.

## Visual Assets
No visual assets provided.

## Requirements Summary

### Functional Requirements
- Shared STEP pulse source generated by ESP32 (hardware-timed) while using per-motor SLEEP gating; each motor’s DIR and SLEEP remain independently controllable.
- Remove per-move and per-home speed/accel parameters from the serial protocol; introduce global `SPEED` and `ACCEL` configuration values with defaults from current code.
- Reject changes to global `SPEED` or `ACCEL` while any motor is moving; respond with error code.
- Enforce that overlapping moves use the single global speed/accel profile.
- Implement microsecond-scale DIR guard windows (constants) around direction flips synchronized to STEP gaps.
- Provide manual bench test routines to compare MCU-tracked position vs. physical position after patterned runs (e.g., back-and-forth rhythms).

### Non-Functional Requirements
- Target reliable operation up to 10 ksteps/s with clean stop/resume and direction changes using SLEEP gating.
- Jitter-free pulse generation even under CPU load and with future Wi‑Fi/ESP‑Now activity.
- Unit tests cover guard timing logic and gating window calculations.

### Reusability Opportunities
- Reuse existing 74HC595-based DIR/SLEEP control and related firmware structures; defer additional gating hardware unless blockers arise.

### Scope Boundaries
**In Scope:**
- Shared-STEP approach with SLEEP gating and DIR control.
- Global speed/accel settings and protocol simplification (parameter removal).
- Minimal step-generation component that can replace FastAccelStepper when feasible.
- Unit tests for guard timing and gating logic.
- Manual bench validation procedures without logic analyzer.

**Out of Scope:**
- Microstepping modes.
- Wireless features beyond ensuring step-generation robustness in future Wi‑Fi scenarios.
- PCB layout or hardware pre-buffers (e.g., LVC14, 125/126) unless blockers identified.
- Telemetry counters or new diagnostics unless later required.

### Technical Considerations
- Prefer ESP32 hardware-timed pulse generation (e.g., RMT or LEDC PWM) to minimize jitter; evaluate a minimal in-house step driver compatible with existing callbacks.
- Maintain DIR/SLEEP over 74HC595; synchronize SLEEP gating and DIR flips to STEP gaps with microsecond guard constants.
- Serial command grammar simplified by removing per-move/home speed/accel; introduce setters/getters for global SPEED/ACCEL with runtime safety checks.
- Ensure concurrency rules: overlapping moves only when speed/accel match globals; reject conflicting operations.

